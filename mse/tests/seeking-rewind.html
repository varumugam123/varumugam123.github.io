<!--
    Usage:
    logEvents=true // log video element events
    moderateTimeupdateLogging=true // moderate timeupdate events

    seeking-rewind.html?moderateTimeupdateLogging=true&seekBeforeBuffering=true&seekCloseToStartOfSegment=true
    seeking-rewind.html?moderateTimeupdateLogging=true&seekBeforeBuffering=true&seekCloseToStartOfSegment=false
    seeking-rewind.html?moderateTimeupdateLogging=true&seekBeforeBuffering=false&seekCloseToStartOfSegment=true
    seeking-rewind.html?moderateTimeupdateLogging=true&seekBeforeBuffering=false&seekCloseToStartOfSegment=false
 -->

 <!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset='UTF-8' />
        <meta http-equiv='Cache-Control' content='no-cache, no-store, must-revalidate' />
        <meta http-equiv='Pragma' content='no-cache' />
        <meta http-equiv='Expires' content='0' />
        <title>MSE Seek Forward Test</title>

        <style>
            video {
                width: 100%;
                height: 100%;
            }

            body {
                margin: 0;
                padding: 0;
                background-color: transparent;
                overflow: hidden;
            }

            #stats {
                position: absolute;
                left: 10px;
                top: 10px;
                background-color: grey;
                color: white;
                font-size: xx-large;
            }

            #errors {
                position: absolute;
                /* left: 10px; */
                top: 250px;
                background-color: red;
                font-size: xx-large;
            }
        </style>
    </head>

    <body>
        <div>
            <video id='videoPlayer' controls autoplay muted=false></video>
            <div>
                <span id='stats' />
            </div>
            <div style="text-align:center;">
                <span id='errors'></span>
            </div>
        </div>

        <script src="../lib/utils.js"></script>
        <script src="../lib/mse.js"></script>
        <script src="../lib/common.js"></script>
        <script src="../lib/feeder.js"></script>

        <script type="text/javascript">
            if (!window.MediaSource) {
                throw 'No Media Source API available'
            }

            var sentTestStatus = false;
            var testPassed = false;
            var shouldSeekBeforeBuffering = checkProp('seekBeforeBuffering');
            var seekCloseToStartOfSegment = checkProp('seekCloseToStartOfSegment');
            var segmentDuration = 4;

            function cleanup() {
                performCommonCleanup();

                if (!sentTestStatus) {
                    sentTestStatus = true;
                    if (testPassed) {
                        document.querySelector('#errors').style.backgroundColor = 'Green';
                        document.querySelector('#errors').innerHTML = "Test Passed";
                        reportPass(true, "Test Passed")
                    } else {
                        document.querySelector('#errors').innerHTML = "Test Failed";
                        reportFail(false, "Test Failed")
                    }
                }
            }

            function onSourceOpen() {
                ms.duration = nextDivisibleNumber(16, segmentDuration)

                let initUrl = 'https://bitdash-a.akamaihd.net/content/MI201109210084_1/video/720_2400000/dash/init.mp4'
                let segmentUrl = 'https://bitdash-a.akamaihd.net/content/MI201109210084_1/video/720_2400000/dash/segment_$Number$.m4s'
                let urls = urlsThroughNumber(segmentUrl, bufferIndexFromTime(ms.duration - segmentDuration, 4, 0), (ms.duration / segmentDuration) - 1)
                urls.unshift(initUrl)

                cacheMediaIfRequiredSync(urls).then(() => {
                    var videoBuffer = ms.addSourceBuffer('video/mp4; codecs="avc1.4d401f"');

                    feeders.video = new Feeder(videoBuffer, urls, () => {
                        if(video.buffered.length > 0) {
                            logMsg("Performing initial forward seek to " + (video.buffered.start(0) + 0.5) + " seconds @ " + video.currentTime);

                            var seekPoint = segmentDuration + ((segmentDuration / 8) * (seekCloseToStartOfSegment ? 1 : -1));
                            waitForEvent(video, 'seeked', 1000).then(() => {
                                return waitForEvent(video, 'playing', 1000);
                            }).then(() => {
                                return waitForTime(1000);
                            }).then(() => {
                                logMsg(`Would be seeking to ${seekPoint} seconds @ ${video.currentTime}`);

                                let feedDataForSeekPoint = (seekPoint, handleDataFeedComplete = null) => {
                                    logMsg("Feeding data for seek point " + seekPoint + " seconds @ " + video.currentTime)
                                    let seekPointIndex = bufferIndexFromTime(seekPoint, segmentDuration, 0);
                                    let bufferedTimePointIndex = bufferIndexFromTime(video.buffered.start(0), segmentDuration, 0);
                                    let urlsToLoad = urlsThroughNumber(segmentUrl, seekPointIndex, bufferedTimePointIndex - 1);
                                    feeders.video = new Feeder(videoBuffer, urlsToLoad, null, null);
                                }

                                if (shouldSeekBeforeBuffering) {
                                    logMsg("Seeking before buffering @ " + video.currentTime)
                                    scheduleTask(() => { feedDataForSeekPoint(seekPoint); }, 1500);
                                } else {
                                    feedDataForSeekPoint(seekPoint);
                                    return waitForCondition(() => {
                                        let bufferLevelToStartSeeking = Math.floor(Math.min(video.duration, (seekPoint + segmentDuration)));
                                        logMsg("Seeking after buffering, waiting for data for position " + bufferLevelToStartSeeking + " seconds @ " + video.currentTime)
                                        return (video.buffered.length > 0 && video.buffered.start(0) <= seekPoint && video.buffered.end(0) >= bufferLevelToStartSeeking);
                                    }, 30000);
                                }
                            }).then(() => {
                                logMsg("Seeking to " + seekPoint + " seconds @ " + video.currentTime);
                                let seekedPromise = waitForEvent(video, 'seeked', 10000);

                                let timeMonitorPromise = waitForEvent(video, 'seeking', 3000).then(() => {
                                    let interval = 50; //milliseconds
                                    let duration = 10 * 1000 //milliseconds
                                    let count = duration / interval;
                                    return monitorTimePolling(seekPoint, interval, count,
                                        () => { return video.seeking ? 0 : (interval / 1000); },
                                        () => { return video.currentTime >= seekPoint + 1; }
                                    );
                                });

                                video.currentTime = seekPoint;

                                return Promise.all([seekedPromise, timeMonitorPromise]);
                            }).then(() => {
                                logMsg("Seeking completed, @ " + video.currentTime);
                                logMsg("Waiting for playback to reach the end (" + Math.floor(video.duration) + ") or seekPoint + segmentDuration + 1 seconds (" + (seekPoint + segmentDuration + 1) + ") (whichever is earlier) @ " + video.currentTime)
                                return waitForCondition(() => ((video.duration - video.currentTime) <= 0.5) || ((video.currentTime - seekPoint) >= (segmentDuration + 1)), 10000);
                            }).then(() => {
                                testPassed = true;
                            }).catch((e) => {
                                logMsg("Criteria failed, " + e);
                            }).finally(() => {
                                cleanup();
                            });

                            video.currentTime = video.buffered.start(0) + 0.5;
                        } else {
                            logMsg("No data available to perform initial forward seek, stopping test");
                            cleanup();
                        }
                    }, null, true);
                });
            }
        </script>
    </body>
</html>