<!--
    Usage:
    logEvents=true // log video element events
    moderateTimeUpdateEvents=true // moderate timeupdate events

    sample-replacement.html?reenqueueVideo=true // video will be reenqueued (implicit) at default time 2.5 seconds
    sample-replacement.html?reenqueueVideoAt=5
    sample-replacement.html?reenqueueVideoAt=5&removeDataOnReenqueue=true // video will be reenqueued at 5 seconds and data will be removed before reenqueueing (explicit)

    sample-replacement.html?audio=true&reenqueueVideo=true&reenqueueVideoAt=5 // audio will be playing, but only video samples will be reenqueued (implicit)
    sample-replacement.html?reenqueueVideoAt=5&reenqueueAudioAt=3 // video will be reenqueued at 5 seconds and audio will be reenqueued at 3 seconds (implicity)
    sample-replacement.html?reenqueueVideoAt=5&reenqueueAudioAt=3&removeDataOnReenqueue=true // video & audio will be reenqueued and data will be removed before reenqueueing (explicit)
    sample-replacement.html?reenqueueVideoAt=3&reenqueueAudioAt=5&removeDataOnReenqueue=true // video & audio will be reenqueued and data will be removed before reenqueueing (explicit)

    sample-replacement.html?reenqueueVideoAt=3&reenqueueAudioAt=3 // video & audio will be reenqueued (implicit)
    sample-replacement.html?reenqueueVideoAt=3&reenqueueAudioAt=3&removeDataOnReenqueue=true // video & audio will be reenqueued and data will be removed before reenqueueing (explicit)
 -->

 <!DOCTYPE html>
<html>
    <head>
        <meta charset='UTF-8' />
        <meta http-equiv='Cache-Control' content='no-cache, no-store, must-revalidate' />
        <meta http-equiv='Pragma' content='no-cache' />
        <meta http-equiv='Expires' content='0' />
        <title>MSE Test</title>

        <style>
        video {
            width: 100%;
            height: 100%;
        }
        body {
            margin:0;
            padding:0;
            background-color:transparent;
            overflow: hidden;
        }
        #stats {
            position: absolute;
            left: 10px;
            top: 10px;
            background-color: grey;
            color: white;
            font-size: xx-large;
        }
        #errors {
            position: absolute;
            /* left: 10px; */
            top: 250px;
            background-color: red;
            font-size: xx-large;
        }
        </style>
    </head>

    <body>
        <div>
            <video id='videoPlayer' controls autoplay muted=false></video>
            <div>
                <span id='stats'/>
            </div>
            <div style="text-align:center;" >
                <span id='errors'></span>
            </div>
        </div>

        <script src="../lib/utils.js"></script>
        <script src="../lib/mse.js"></script>
        <script src="../lib/big_buck_bunny_720p_30fps.js"></script>
        <script src="../lib/common.js"></script>
        <script src="../lib/feeder.js"></script>

        <script type='text/javascript'>
            if (!window.MediaSource) {
                throw 'No Media Source API available'
            }

            var reenqueueVideoAt = getParamValue('reenqueueVideoAt')
            var reenqueueAudioAt = getParamValue('reenqueueAudioAt')
            var reenqueueVideo = checkProp('reenqueueVideo') || (reenqueueVideoAt != -1)
            var reenqueueAudio = checkProp('reenqueueAudio') || (reenqueueAudioAt != -1)
            var removeDataOnReenqueue = checkProp('removeDataOnReenqueue')
            var enableAudio = checkProp('audio') || reenqueueAudio

            if(reenqueueVideoAt != -1 && reenqueueAudioAt == -1)
                reenqueueAudioAt = reenqueueVideoAt;
            else if(reenqueueAudioAt != -1 && reenqueueVideoAt == -1)
                reenqueueVideoAt = reenqueueAudioAt;
            else if(reenqueueAudioAt == -1 && reenqueueVideoAt == -1) {
                reenqueueVideoAt = 2.5;
                reenqueueAudioAt = 2.5;
            }

            var sentTestStatus = false;
            var testPassed = false;

            function cleanup() {
                performCommonCleanup();

                if (!sentTestStatus) {
                    sentTestStatus = true;
                    if (testPassed) {
                        document.querySelector('#errors').style.backgroundColor = 'Green';
                        document.querySelector('#errors').innerHTML = "Test Passed";
                        reportPass(true, "Test Passed")
                    } else {
                        document.querySelector('#errors').innerHTML = "Test Failed";
                        reportFail(false, "Test Failed")
                    }
                }
            }

            function onFeedEnded() {
                for (let key in feeders)
                    if (feeders.hasOwnProperty(key) && feeders[key] && !(feeders[key].ended))
                        return
                logMsg("All feeders ended");

                if(window.scheduledMonitorForEnded === undefined) {
                    window.scheduledMonitorForEnded = true;

                    waitForCondition(function () {
                            return (video.currentTime >= (video.duration - 1));
                        }, ((video.duration - video.currentTime) * 1000) + 1000)
                    .then(() => {
                        testPassed = true;
                        logMsg("Test completed successfully");
                        cleanup();
                    }).catch((error) => {
                        logMsg("Test Failed, " + error);
                        cleanup()
                    })
                }
            }

            function checkBufferPercentageAndwaitForCondition(isVideo, bufferPercentage) {
                // logMsg("checkBufferPercentageAndwaitForCondition: " + isVideo + " : " + video.readyState.toString() + ", " + bufferPercentage);

                let feeder = isVideo ? feeders.video : feeders.audio;
                if(feeder === undefined || feeder == null)
                    return;

                // wait for two buffers (including initialization segment) to start playback from 0 and wait for 1 buffer on reenqueue
                let buffersToStartMonitoringForPlaying = (feeder.reenqueue && feeder.doneReenqueuing) ? 1 : 2;

                // Once enough buffers to get the playback started are appended remove appendBufferCompletion monitoring
                if(feeder.bufferCount == buffersToStartMonitoringForPlaying)
                    feeder.appendComplete = undefined;

                let allSourceBuffersHaveData = allFeedersMeetCondition((feeder, isVideo) => {
                    return (feeder.appendComplete === undefined);
                });

                // When all sources have enough buffers to get started
                if (allSourceBuffersHaveData) {
                    waitForCondition(checkForPlaying, 10000, "Enough data is fed, but playback hasn't started").then(() => {
                        logMsg("Player started playback");
                        if(feeder.doneReenqueuing) {
                            let expectedTime = isVideo ? feeders.video.timeOfReenqueue : feeders.audio.timeOfReenqueue
                            let finishMonitoringAt = expectedTime + 1.5;
                            return monitorTimePolling(expectedTime, 100, 100, () => (0.060), () => (video.currentTime >= finishMonitoringAt));
                            // return monitorTimeOnUpdateEvent(video, expectedTime, 100, () => (0.250), () => (video.currentTime >= finishMonitoringAt));
                        }
                    }).catch((error) => {
                        logMsg(error);
                        cleanup()
                    })
                }
            }

            var finishOrRenenqueue = (isVideo, urls, reenqueueTime) => {
                if (feeders.video == null && feeders.audio == null)
                    return;

                let feeder = (isVideo ? feeders.video : feeders.audio);
                let shouldReenqueue = (isVideo ? feeders.video.reenqueue : feeders.audio.reenqueue);
                let shouldRemoveFragment = (isVideo ? feeders.video.removeFragment : feeders.audio.removeFragment);
                let sourceBuffer = isVideo ? feeders.video.sourceBuffer : feeders.audio.sourceBuffer;

                if (shouldReenqueue) {
                    if (feeder.scheduledReenqueueAt !== undefined && feeder.scheduledReenqueueAt != -1 && video.currentTime < feeder.scheduledReenqueueAt) {
                        let delta = (feeder.scheduledReenqueueAt >= video.currentTime) ? (feeder.scheduledReenqueueAt - video.currentTime) * 1000 : 0;
                        let timeOut = (delta > 50) ? delta : 50;
                        logMsg("Scheduling task to reenqueue in " + timeOut + " ms, for " + (isVideo ? "Video" : "Audio") + " @ " + video.currentTime);
                        setTimeout(() => { finishOrRenenqueue(isVideo, urls, feeder.reenqueueAt); }, timeOut);
                        return;
                    }

                    let timeOfReenqueue = video.currentTime;
                    var attachNewFeeder = function () {
                        let newFeeder = new Feeder(sourceBuffer, urls, onFeedEnded, checkBufferPercentageAndwaitForCondition, isVideo);
                        newFeeder.reenqueue = feeder.reenqueue;
                        newFeeder.scheduledReenqueueAt = feeder.scheduledReenqueueAt;
                        newFeeder.removeFragment = feeder.removeFragment;
                        newFeeder.timeOfReenqueue = timeOfReenqueue
                        newFeeder.doneReenqueuing= true;

                        if (isVideo)
                            feeders.video = newFeeder;
                        else
                            feeders.audio = newFeeder;

                        logMsg("Attached new feeder for " + (isVideo ? "Video" : "Audio"));
                    }

                    if (shouldRemoveFragment) {
                        sourceBuffer.onupdateend = () => {
                            sourceBuffer.onupdateend = undefined;
                            attachNewFeeder();
                        };
                        logMsg("Removing " + (isVideo ? "Video" : "Audio") + " buffers @ " + video.currentTime);
                        sourceBuffer.remove(0, 100);
                        logMsg("Removed " + (isVideo ? "Video" : "Audio") + " buffers {0,20}");
                    } else {
                        attachNewFeeder();
                    }
                } else {
                    onFeedEnded();
                }
            }

            function onSourceOpen() {
                ms.duration = 12 // maxFetchIdx * segmentDuration

                if (enableAudio) {
                    var audioBuffer = ms.addSourceBuffer('audio/mp4; codecs="mp4a.40.2"')
                    feeders.audio = new Feeder(audioBuffer, urlsThroughNumber(audioUrls[0], 0, 3), () => {
                        finishOrRenenqueue(false, urlsThroughNumber(audioUrls[0], bufferIndexFromTime(video.currentTime), 3))
                    }, checkBufferPercentageAndwaitForCondition, false);
                }

                var videoBuffer = ms.addSourceBuffer('video/mp4; codecs="avc1.640028"')
                feeders.video = new Feeder(videoBuffer, urlsThroughNumber(videoUrls[0], 0, 3), () => {
                    finishOrRenenqueue(true, urlsThroughNumber(videoUrls[0], bufferIndexFromTime(video.currentTime), 3))
                }, checkBufferPercentageAndwaitForCondition, true);

                [true, false].forEach((isVideo) => {
                    let feeder = isVideo ? feeders.video : feeders.audio;
                    if(feeder === undefined || feeder == null)
                        return;
                    feeder.reenqueue = isVideo ? reenqueueVideo : reenqueueAudio;
                    feeder.scheduledReenqueueAt = isVideo ? reenqueueVideoAt : reenqueueAudioAt;
                    feeder.removeFragment = removeDataOnReenqueue;
                    feeder.doneReenqueuing = false

                    logMsg((isVideo ? "Video" : "Audio") + ", Reenqueue:" + feeder.reenqueue + ", ReenqueueAt:" + feeder.scheduledReenqueueAt + ", RemoveDataOnReenqueue:" + feeder.removeFragment);
                })
            }
        </script>
    </body>
</html>